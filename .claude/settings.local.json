{
  "permissions": {
    "allow": [
      "Bash(npm run dev:*)",
      "Bash(Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy RemoteSigned -Force)",
      "Bash(npx tsx:*)",
      "Bash(node -e:*)",
      "Bash(git config:*)",
      "Bash(git remote add:*)",
      "Bash(git add:*)",
      "Bash(git restore:*)",
      "Bash(git commit:*)",
      "Bash(git push:*)",
      "Bash(npx vercel env add:*)",
      "Bash(npm install:*)",
      "Bash(git stash:*)",
      "Bash(ls:*)",
      "Bash(.ts \")",
      "Bash(\"c:\\\\Users\\\\dinnh\\\\Desktop\\\\blog\\\\app\\\\api\\\\feed\\\\route.ts\" << 'EOF'\nimport { NextResponse } from 'next/server'\n\nconst SUPA_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!\nconst KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\nconst h = { 'apikey': KEY, 'Authorization': `Bearer ${KEY}`, 'Content-Type': 'application/json' }\n\nexport async function GET\\(request: Request\\) {\n    try {\n        const { searchParams } = new URL\\(request.url\\)\n        const user_id = searchParams.get\\('user_id'\\)\n        let query = `${SUPA_URL}/rest/v1/feed_posts?order=created_at.desc&select=*,profiles\\(username,avatar_url\\)`\n        if \\(user_id\\) query += `&user_id=eq.${user_id}`\n        const res = await fetch\\(query, { headers: h }\\)\n        const data = await res.json\\(\\)\n        return NextResponse.json\\(Array.isArray\\(data\\) ? data : []\\)\n    } catch \\(e: any\\) {\n        return NextResponse.json\\({ error: e.message }, { status: 500 }\\)\n    }\n}\n\nexport async function POST\\(request: Request\\) {\n    try {\n        const { user_id, content, image_url } = await request.json\\(\\)\n        if \\(!user_id || !content?.trim\\(\\)\\) {\n            return NextResponse.json\\({ error: 'Dados incompletos' }, { status: 400 }\\)\n        }\n\n        const body: any = { user_id, content: content.trim\\(\\) }\n        if \\(image_url\\) body.image_url = image_url\n\n        const res = await fetch\\(`${SUPA_URL}/rest/v1/feed_posts`, {\n            method: 'POST',\n            headers: { ...h, 'Prefer': 'return=representation' },\n            body: JSON.stringify\\(body\\)\n        }\\)\n        const data = await res.json\\(\\)\n        return NextResponse.json\\(data[0] || {}\\)\n    } catch \\(e: any\\) {\n        return NextResponse.json\\({ error: e.message }, { status: 500 }\\)\n    }\n}\nEOF)",
      "Bash(\"c:\\\\Users\\\\dinnh\\\\Desktop\\\\blog\\\\app\\\\api\\\\feedback\\\\route.ts\" << 'EOF'\nimport { NextResponse } from 'next/server'\n\nconst SUPA_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!\nconst KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\nconst h = { 'apikey': KEY, 'Authorization': `Bearer ${KEY}`, 'Content-Type': 'application/json' }\n\nexport async function GET\\(request: Request\\) {\n    try {\n        const { searchParams } = new URL\\(request.url\\)\n        const type = searchParams.get\\('type'\\)\n        const status = searchParams.get\\('status'\\)\n        const user_id = searchParams.get\\('user_id'\\)\n\n        let query = `${SUPA_URL}/rest/v1/feedback?order=created_at.desc`\n        if \\(type\\) query += `&type=eq.${type}`\n        if \\(status\\) query += `&status=eq.${status}`\n        if \\(user_id\\) query += `&user_id=eq.${user_id}`\n\n        const res = await fetch\\(query, { headers: h }\\)\n        const data = await res.json\\(\\)\n        return NextResponse.json\\(Array.isArray\\(data\\) ? data : []\\)\n    } catch \\(e: any\\) {\n        return NextResponse.json\\({ error: e.message }, { status: 500 }\\)\n    }\n}\n\nexport async function POST\\(request: Request\\) {\n    try {\n        const { user_id, username, email, type, title, content } = await request.json\\(\\)\n        if \\(!title || !content\\) return NextResponse.json\\({ error: 'Dados incompletos' }, { status: 400 }\\)\n\n        const res = await fetch\\(`${SUPA_URL}/rest/v1/feedback`, {\n            method: 'POST',\n            headers: { ...h, 'Prefer': 'return=representation' },\n            body: JSON.stringify\\({ user_id, username, email, type: type || 'suggestion', title, content }\\)\n        }\\)\n        const data = await res.json\\(\\)\n        return NextResponse.json\\(data[0] || {}\\)\n    } catch \\(e: any\\) {\n        return NextResponse.json\\({ error: e.message }, { status: 500 }\\)\n    }\n}\n\nexport async function PATCH\\(request: Request\\) {\n    try {\n        const { id, status } = await request.json\\(\\)\n        if \\(!id\\) return NextResponse.json\\({ error: 'Missing id' }, { status: 400 }\\)\n\n        await fetch\\(`${SUPA_URL}/rest/v1/feedback?id=eq.${id}`, {\n            method: 'PATCH',\n            headers: { ...h, 'Prefer': 'return=minimal' },\n            body: JSON.stringify\\({ status }\\)\n        }\\)\n        return NextResponse.json\\({ ok: true }\\)\n    } catch \\(e: any\\) {\n        return NextResponse.json\\({ error: e.message }, { status: 500 }\\)\n    }\n}\n\nexport async function DELETE\\(request: Request\\) {\n    const { searchParams } = new URL\\(request.url\\)\n    const id = searchParams.get\\('id'\\)\n    if \\(!id\\) return NextResponse.json\\({ error: 'Missing id' }, { status: 400 }\\)\n    await fetch\\(`${SUPA_URL}/rest/v1/feedback?id=eq.${id}`, { method: 'DELETE', headers: h }\\)\n    return NextResponse.json\\({ ok: true }\\)\n}\nEOF)",
      "Bash(\"c:\\\\Users\\\\dinnh\\\\Desktop\\\\blog\\\\app\\\\api\\\\escritas\\\\route.ts\" << 'EOF'\nimport { NextResponse } from 'next/server'\n\nconst SUPA_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!\nconst KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\nconst h = { 'apikey': KEY, 'Authorization': `Bearer ${KEY}`, 'Content-Type': 'application/json' }\n\nexport async function GET\\(request: Request\\) {\n    try {\n        const { searchParams } = new URL\\(request.url\\)\n        const sort = searchParams.get\\('sort'\\) || 'recent'\n        const category = searchParams.get\\('category'\\)\n        const admin = searchParams.get\\('admin'\\)\n        const status = searchParams.get\\('status'\\) || \\(admin ? undefined : 'published'\\)\n        const user_id = searchParams.get\\('user_id'\\)\n\n        let query = `${SUPA_URL}/rest/v1/escritas_livres?select=*,profiles\\(username,avatar_url\\)`\n\n        if \\(status\\) query += `&status=eq.${status}`\n        if \\(category\\) query += `&category=eq.${category}`\n        if \\(user_id\\) query += `&user_id=eq.${user_id}`\n\n        if \\(sort === 'likes'\\) query += '&order=likes.desc,created_at.desc'\n        else if \\(sort === 'views'\\) query += '&order=views.desc,created_at.desc'\n        else query += '&order=pinned.desc,created_at.desc'\n\n        const res = await fetch\\(query, { headers: h }\\)\n        const data = await res.json\\(\\)\n        return NextResponse.json\\(Array.isArray\\(data\\) ? data : []\\)\n    } catch \\(e: any\\) {\n        return NextResponse.json\\({ error: e.message }, { status: 500 }\\)\n    }\n}\n\nexport async function POST\\(request: Request\\) {\n    try {\n        const { user_id, title, content, category, image_url } = await request.json\\(\\)\n        if \\(!user_id || !title || !content\\) {\n            return NextResponse.json\\({ error: 'Dados incompletos' }, { status: 400 }\\)\n        }\n\n        const body: any = { user_id, title, content, category: category || 'geral', status: 'pending' }\n        if \\(image_url\\) body.image_url = image_url\n\n        const res = await fetch\\(`${SUPA_URL}/rest/v1/escritas_livres`, {\n            method: 'POST',\n            headers: { ...h, 'Prefer': 'return=representation' },\n            body: JSON.stringify\\(body\\)\n        }\\)\n        const data = await res.json\\(\\)\n        return NextResponse.json\\(data[0] || {}\\)\n    } catch \\(e: any\\) {\n        return NextResponse.json\\({ error: e.message }, { status: 500 }\\)\n    }\n}\nEOF)",
      "Bash(\"c:\\\\Users\\\\dinnh\\\\Desktop\\\\blog\\\\app\\\\api\\\\comments\\\\route.ts\" << 'ENDOFFILE'\nimport { NextResponse } from 'next/server'\nimport { filterProfanity } from '@/lib/profanity'\n\nconst SUPA_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!\nconst KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\nconst h = { 'apikey': KEY, 'Authorization': `Bearer ${KEY}`, 'Content-Type': 'application/json' }\n\nexport async function GET\\(request: Request\\) {\n    const { searchParams } = new URL\\(request.url\\)\n    const post_id = searchParams.get\\('post_id'\\)\n    const admin = searchParams.get\\('admin'\\)\n    const user_id = searchParams.get\\('user_id'\\)\n\n    if \\(!post_id && !admin && !user_id\\) return NextResponse.json\\([]\\)\n\n    let filter = ''\n    if \\(post_id\\) filter += `post_id=eq.${post_id}&`\n    if \\(user_id\\) filter += `user_id=eq.${user_id}&`\n\n    const res = await fetch\\(\n        `${SUPA_URL}/rest/v1/comments?${filter}order=created_at.desc&select=*,profiles\\(username,avatar_url\\)`,\n        { headers: h }\n    \\)\n    const data = await res.json\\(\\)\n    return NextResponse.json\\(Array.isArray\\(data\\) ? data : []\\)\n}\n\nexport async function PATCH\\(request: Request\\) {\n    try {\n        const { id, likes } = await request.json\\(\\)\n        if \\(!id\\) return NextResponse.json\\({ error: 'Missing id' }, { status: 400 }\\)\n        await fetch\\(`${SUPA_URL}/rest/v1/comments?id=eq.${id}`, {\n            method: 'PATCH',\n            headers: { ...h, 'Prefer': 'return=minimal' },\n            body: JSON.stringify\\({ likes }\\)\n        }\\)\n        return NextResponse.json\\({ ok: true }\\)\n    } catch \\(e: any\\) {\n        return NextResponse.json\\({ error: e.message }, { status: 500 }\\)\n    }\n}\n\nexport async function POST\\(request: Request\\) {\n    try {\n        const { post_id, user_id, content } = await request.json\\(\\)\n        if \\(!post_id || !user_id || !content?.trim\\(\\)\\) {\n            return NextResponse.json\\({ error: 'Dados incompletos' }, { status: 400 }\\)\n        }\n\n        const filtered = filterProfanity\\(content.trim\\(\\)\\)\n\n        const res = await fetch\\(`${SUPA_URL}/rest/v1/comments`, {\n            method: 'POST',\n            headers: { ...h, 'Prefer': 'return=representation' },\n            body: JSON.stringify\\({ post_id, user_id, content: filtered }\\)\n        }\\)\n        const data = await res.json\\(\\)\n        return NextResponse.json\\(data[0] || {}\\)\n    } catch \\(e: any\\) {\n        return NextResponse.json\\({ error: e.message }, { status: 500 }\\)\n    }\n}\n\nexport async function DELETE\\(request: Request\\) {\n    const { searchParams } = new URL\\(request.url\\)\n    const id = searchParams.get\\('id'\\)\n    const user_id = searchParams.get\\('user_id'\\)\n    if \\(!id\\) return NextResponse.json\\({ error: 'Missing id' }, { status: 400 }\\)\n\n    const filter = \\(!user_id || user_id === 'admin'\\)\n        ? `id=eq.${id}`\n        : `id=eq.${id}&user_id=eq.${user_id}`\n    await fetch\\(`${SUPA_URL}/rest/v1/comments?${filter}`, {\n        method: 'DELETE', headers: h\n    }\\)\n    return NextResponse.json\\({ ok: true }\\)\n}\nENDOFFILE)",
      "Bash(python3:*)",
      "Bash(node write_files.js:*)",
      "Bash(node write_perfil.js:*)",
      "Bash(dir:*)",
      "Bash(Get-Content \"c:\\\\Users\\\\dinnh\\\\Desktop\\\\blog\\\\app\\\\comunidade\\\\grupos\\\\[id]\\\\page.tsx\" -Raw)",
      "Bash(Select-String -Pattern \"Check membership from API\" -Context 10,5)",
      "Bash(ForEach-Object { $_Context.PreContext)",
      "Bash($_Line)",
      "Bash($_Context.PostContext })"
    ]
  }
}
